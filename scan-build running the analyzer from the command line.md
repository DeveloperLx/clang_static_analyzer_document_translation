# scan-build: 从命令行中运行分析器
---
#### [原文地址](http://clang-analyzer.llvm.org/scan-build.html) 翻译：[DeveloperLx](http://weibo.com/DeveloperLx)

<div id="content">
    <table style="margin-top:0px" width="100%" cellpadding="0px" cellspacing="0">
        <tbody>
            <tr>
                <td>
                    <h3>
                        它是什么？
                    </h3>
                    <p>
                        <b>
                            scan-build
                        </b>
                        是一个命令行的工具，让用户能够在它们的代码库上运行静态分析，作为正常build的一部分（从命令行）。
                    </p>
                    <h3>
                        它怎么工作？
                    </h3>
                    <p>
                        在项目build期间，当源文件被编译的时候，也通过静态分析器串联了分析。
                    </p>
                    <p>
                        当build完成后，结果会在一个web浏览器中展示给用户。
                    </p>
                    <h3>
                        它在任何build系统下都能工作么？
                    </h3>
                    <p>
                        <b>
                            scan-build
                        </b>
                        对于你怎么build你的code了解得很少。它通过覆盖
                        <tt>
                            CC
                        </tt>
                        和
                        <tt>
                            CXX
                        </tt>
                        环境下的变量，来（有希望地）改变你的build去使用一个“假的”编译器，来替换那个能够正常build你的项目的以工作。这个假编译器执行
                        <tt>
                            clang
                        </tt>
                        或
                        <tt>
                            gcc
                        </tt>
                        （依赖于平台）来编译你的代码，然后执行静态分析去分析你的代码。
                    </p>
                    <p>
                        这个”穷人的干涉“的工作在很多的情况下令人惊奇得好，其它失败。请在这页查阅关于最好地使用
                        <b>
                            scan-build
                        </b>
                        的信息，它包含当前面提到的hack工作失败时该怎么办。
                    </p>
                </td>
                <td style="padding-left:10px; text-align:center">
                    <img src="http://clang-analyzer.llvm.org/images/scan_build_cmd.png" width="450px" alt="scan-build">
                    <br>
                    <a href="http://clang-analyzer.llvm.org/images/analyzer_html.png">
                        <img src="http://clang-analyzer.llvm.org/images/analyzer_html.png" width="450px" alt="analyzer in browser">
                    </a>
                    <br>
                    <b>
                        在web浏览器中查看静态分析的结果
                    </b>
                </td>
            </tr>
        </tbody>
    </table>
    <h2>
        内容
    </h2>
    <ul>
        <li>
            <a href="#scanbuild">
                开始吧！
            </a>
            <ul>
                <li>
                    <a href="#scanbuild_basicusage">
                        基本用法
                    </a>
                </li>
                <li>
                    <a href="#scanbuild_forwindowsusers">
                        对于Windows用户
                    </a>
                </li>
                <li>
                    <a href="#scanbuild_otheroptions">
                        其它选项
                    </a>
                </li>
                <li>
                    <a href="#scanbuild_output">
                        scan-build的输出
                    </a>
                </li>
            </ul>
        </li>
        <li>
            <a href="#recommendedguidelines">
                推荐的用法参考
            </a>
            <ul>
                <li>
                    <a href="#recommended_debug">
                        永远使用“Debug”配置来分析项目
                    </a>
                </li>
                <li>
                    <a href="#recommended_verbose">
                        在debug scan-build时使用详细的输出
                    </a>
                </li>
                <li>
                    <a href="#recommended_autoconf">
                        通过scan-build来执行'./configure' 
                    </a>
                </li>
            </ul>
        </li>
        <li>
            <a href="#recommendedguidelines">
                debug分析器
            </a>
            <ul>
                <li>
                    <a href="#recommended_debug">
                        它怎么工作
                    </a>
                </li>
            </ul>
        </li>
        <li>
            <a href="#iphone">
                分析iPhone项目
            </a>
        </li>
    </ul>
    <h2 id="scanbuild">
        开始吧！
    </h2>
    <p>
        <tt>
            scan-build
        </tt>
        命令可以用来通过本质上地干预项目的build过程，来分析一个整个的项目。这意味着为了使用
        <tt>
            scan-build
        </tt>
        来执行分析器，你可以使用
        <tt>
            scan-build
        </tt>
        ，来分析在项目build期间由
        <tt>
            gcc
        </tt>
        /
        <tt>
            clang
        </tt>
        编译的源文件。同时这也意味着任何没有被编译的文件也不会被分析。
    </p>
    <h3 id="scanbuild_basicusage">
        基本用法
    </h3>
    <p>
        <tt>
            scan-build
        </tt>
        的基本用法是很简单的：只需将"scan-build"放到你build命令的前面：
    </p>
    <pre class="code_example">$ <span class="code_highlight">scan-build</span> make
$ <span class="code_highlight">scan-build</span> xcodebuild
</pre>
    <p>
        第一种情况
        <tt>
            scan-build
        </tt>
        分析了使用
        <tt>
            make
        </tt>
        build的项目的代码，第二种情况
        <tt>
            scan-build
        </tt>
        分析了使用
        <tt>
            xcodebuild
        </tt>
        build的项目
    </p>
    <p>
    </p>
    <p>
        这个是调用
        <tt>
            scan-build
        </tt>
        的一般的格式：
    </p>
    <pre class="code_example">$ <span class="code_highlight">scan-build</span> <i>[scan-build options]</i> <span class="code_highlight">&lt;command&gt;</span> <i>[command options]</i>
</pre>
    <p>
        在操作上，
        <tt>
            scan-build
        </tt>
        用全部随后传给它的选项，照字面地运行了&lt;command&gt;。例如，可以传递
        <tt>
            -j4
        </tt>
        选项到
        <tt>
            make
        </tt>
        来获取4核的并行执行：
    </p>
    <pre class="code_example">$ scan-build make <span class="code_highlight">-j4</span>
</pre>
    <p>
        在大多情况下，
        <tt>
            scan-build
        </tt>
        不需要转换build命令后面的选项；一般来说，
        <tt>
            scan-build
        </tt>
        支持并行地build，
        <b>
            但不支持分布式的build
        </b>
        。
    </p>
    <p>
        使用
        <tt>
            scan-build
        </tt>
        去分析指定的文件也是可以的：
    </p>
    <pre class="code_example"> $ scan-build gcc -c <span class="code_highlight">t1.c t2.c</span>
</pre>
    <p>
        这个例子分析了
        <tt>
            t1.c
        </tt>
        和
        <tt>
            t2.c
        </tt>
        文件。
    </p>
    <h3 id="scanbuild_forwindowsusers">
        对于Windows用户
    </h3>
    <p>
        Windows用户必须安装了Perl，才能使用scan-build。
    </p>
    <p>
        <tt>
            scan-build.bat
        </tt>
        脚本，让你可以以与上面基本用法描述一样的方式运行scan-build。为了从任意的位置调用scan-build，添加包含scan-build.bat的目录的路径到你的PATH环境变量中。
    </p>
    <p>
        当使用MinGW/MSYS运行scan-build时，如果你遇到了意外的compilation/make问题，下面的信息或许是有帮助的：
    </p>
    <ul>
        <li>
            当从Windows的cmd中，使用MSYS来build时，如果意外地得到了
            <tt>
                "fatal error: no input files"
            </tt>
            ，尝试以下解决方案中的一种：
        </li>
        <ul>
            <li>
                使用MinGW
                <tt>
                    mingw32-make
                </tt>
                替换MSYS
                <tt>
                    make
                </tt>
                ，并从PATH中排除到MSYS的路径，来避免
                <tt>
                    mingw32-make
                </tt>
                使用MSYS工具。MSYS依赖于MSYS的运行时，它并没有打算被Windows的cmd执行。特别地，当传入使用反引号的makefile命令，会严重地破坏执行。
            </li>
            <li>
                从sh shell运行
                <tt>
                    make
                </tt>
                ：
                <pre class="code_example">$ <span class="code_highlight">scan-build</span> <i>[scan-build options]</i> sh -c "make <i>[make options]</i>"
</pre>
            </li>
        </ul>
        <li>
            当使用GNU Make 3.81时，如果获得了
            <tt>
                "Error : *** target pattern contains no `%'"
            </tt>
            ，尝试使用另一个版本的make。
        </li>
    </ul>
    <h3 id="scanbuild_otheroptions">
        其它选项
    </h3>
    <p>
        正如上面提到的，额外的选项可以传递给
        As mentioned above, extra options can be passed to
        <tt>
            scan-build
        </tt>
        。这些选项给build命令添加了前缀。例如：
    </p>
    <pre class="code_example"> $ scan-build <span class="code_highlight">-k -V</span> make
 $ scan-build <span class="code_highlight">-k -V</span> xcodebuild
</pre>
    <p>
        这里是部分可用的选项：
    </p>
    <table class="options">
        <colgroup>
            <col class="option">
                <col class="description">
        </colgroup>
        <thead>
            <tr>
                <td>
                    选项
                </td>
                <td>
                    描述
                </td>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>
                    <b>
                        -o
                    </b>
                </td>
                <td>
                	HTML报告文件的目标目录。当需要表示分析的单独的“执行”时，会创建子目录。如果没有指定这个选项，目录将创建在
                    <tt>
                        /tmp
                    </tt>
                    来保存报告。
                </td>
            </tr>
            <tr>
                <td>
                    <b>
                        -h
                    </b>
                    <br>
                    <i>
                        (或没有参数时)
                    </i>
                </td>
                <td>
                	展示全部的
                    <tt>
                        scan-build
                    </tt>
                    选项。
                </td>
            </tr>
            <tr>
                <td>
                    <b>
                        -k
                    </b>
                    <br>
                    <b>
                        --keep-going
                    </b>
                </td>
                <td>
                	添加一个“保持继续”（keep on going）选项到指定的build目录。
                    <p>
                    	这个选项当前支持
                        <tt>
                            make
                        </tt>
                        和
                        <tt>
                            xcodebuild
                        </tt>
                        。
                    </p>
                    <p>
                    	它是一个便利选项；可以直接使用build选项来指定这个行为。
                    </p>
                </td>
            </tr>
            <tr>
                <td>
                    <b>
                        -v
                    </b>
                </td>
                <td>
                	从scan-build何分析器详细地输出。
                    <b>
                    	第二和第三个“-v”会增加详细程度
                    </b>
                    ，这对于给分析器归档bug报告是非常有用的。
                </td>
            </tr>
            <tr>
                <td>
                    <b>
                        -V
                    </b>
                </td>
                <td>
                	当build命令完成后，在web浏览器中查看分析结果。
                </td>
            </tr>
            <tr>
                <td>
                    <b>
                        --use-analyzer Xcode
                    </b>
                    <br>
                    <i>
                        或
                    </i>
                    <br>
                    <b>
                        --use-analyzer [path to clang]
                    </b>
                </td>
                <td>
                    <tt>
                        scan-build
                    </tt>
                    为静态分析使用相对于它自己可执行的'clang' 。可以通过这个选项来覆盖这个行为，通过使用这个由Xcode打包，或从PATH而来的'clang'。
                    <p>
                    </p>
                </td>
            </tr>
        </tbody>
    </table>
    <p>
        不带任何参数地运行
        <tt>
            scan-build
        </tt>
        可以获得完整的选项列表。
    </p>
    <h3 id="scanbuild_output">
        scan-build的输出
    </h3>
    <p>
    	scan-build的输出是一整套的HTML文件，每个都代表一个单独的bug报告。一个单独的
        <tt>
            index.html
        </tt>
        文件是用来考察全部的bug的。你可以在浏览器中只打开
        <tt>
            index.html
        </tt>
        来查看bug报告。
    </p>
    <p>
    	<tt>
            scan-build
        </tt>
        在哪里生成HTML文件可以由        
        <b>
            -o
        </b>
        选项来确定。如果未指定
        <b>
            -o
        </b>
        选项，则会在
        <tt>
            /tmp
        </tt>
        中创建一个目录来储存文件（
        <tt>
            scan-build
        </tt>
        会打印一条信息来告诉你这个路径）。如果你想在build完成后直接查看报告，传递
        <b>
            -V
        </b>
        选项给
        <tt>
            scan-build
        </tt>
        。
    </p>
    <h2 id="recommendedguidelines">
        推荐的用法参考
    </h2>
    <p>
    	这一部分描述几条运行分析器时的建议。
    </p>
    <h3 id="recommended_debug">
        永远使用“Debug”配置来分析项目
    </h3>
    <p>
    	大多数项目可以build在“debug”模式下，它会打开断言。断言会被静态分析器捡起来减少不可实行的路径，在一些情形下可以很大程度低减少这个工具给出的错误报告（假的（bogus）错误报告）的数量。
    </p>
    <p>
    	另一个选项是使用
    	<b>
            scan-build
        </b>
        工具的
        <tt>
            --force-analyze-debug-code
        </tt>
        标记
        <b>
            scan-build
        </b>
        ，它会自动地打开断言。
    </p>
    <h3 id="recommend_verbose">
        在debug scan-build时使用详细的输出
    </h3>
    <p>
    	使用
        <b>
            -v
        </b>
        选项，
        <tt>
            scan-build
        </tt>
        会给出关于它正在做什么的详细的输出；两个
        <b>
            -v
        </b>
        选项就会给出更多的信息。重定向
        <tt>
            scan-build
        </tt>
        的输出到一个文本文件（确保重定向标准错误）对于归档bug报告是非常有用的，这样我们就可以看到传递给分析器的准确的选项（和文件）。为了让日志更容易理解，不要执行并行的build。
    </p>
    <h3 id="recommended_autoconf">
        通过scan-build来执行'./configure' 
    </h3>
    <p>
    	如果一个被分析的工程使用autoconf生成了
        <tt>
            configure
        </tt>
        脚本，为了分析工程，你或许需要通过
        <tt>
            scan-build
        </tt>
        运行
        <tt>
            configure
        </tt>
        脚本。
    </p>
    <p>
        <b>
            Example
        </b>
    </p>
    <pre class="code_example">$ scan-build ./configure $ scan-build make</pre>
    <p>
        <tt>
            configure
        </tt>
        也需要通过
        <tt>
            scan-build
        </tt>
        来执行的原因是
        <tt>
            scan-build
        </tt>
        扫你的源文件是通过
        <i>
            介入（interposing）
        </i>
        编译器实现的。这个介入当前是通过
        <tt>
            scan-build
        </tt>
        设置环境变量
        <tt>
            CC
        </tt>
        到
        <tt>
            ccc-analyzer
        </tt>
        实现的。
        <tt>
            ccc-analyzer
        </tt>
        程序扮演了一个假的编译器，转发编译器的命令行参数，去执行常规的编译和
        <tt>
            clang
        </tt>
        静态分析。
    </p>
    <p>
        运行
        <tt>
            configure
        </tt>
        典型地生成makefile，它带有硬连线的（hardwired）到编译器的路径。通过
        <tt>
            scan-build
        </tt>
        执行
        <tt>
            configure
        </tt>
        ，那个路径被设置为
        <tt>
            ccc-analyzer
        </tt>
        。
    </p>
  	<h2 id="Debugging">
    debug分析器
</h2>
<p>
    这个部分提供了关于debug分析器的信息，并在当你分析一个特定的项目遇到问题时解决它。
</p>
<h3>
    它怎么工作
</h3>
<p>
	为了分析一个项目，
    <tt>
        scan-build
    </tt>
    简单地设置环境变量
    <tt>
        CC
    </tt>
    为到
    <tt>
        ccc-analyzer
    </tt>
    的全路径。它也设置几个环境变量来告知
    <tt>
        ccc-analyzer
    </tt>
    在何处生成（dump）HTML报告文件。
</p>
<p>
	一些makefile（或等价的项目文件）硬编码了编译器；这样的项目简单地覆盖了
    <tt>
        CC
    </tt>
    这个环境变量，造成
    <tt>
        ccc-analyzer
    </tt>
    无法被调用。这就会造成编译的代码
    <b>
    	无法被分析。
    </b>
</p>
如果你发现你的代码无法被分析，检查一下是否是
<tt>
    CC
</tt>
被硬编码了。如果是这个原因，你可以硬编码到
<tt>
    ccc-analyzer
</tt>
的
<b>
    全路径
</b>
硬编码地替换它。
</p>
<p>
	在合适的情况下（applicable），你也可以通过
	<tt>
        scan-build
    </tt>
    为一个项目运行
    <tt>
        ./configure
    </tt>
    。这样configure就基于传入给
    <tt>
        scan-build
    </tt>
    的环境，设置了
    <tt>
        CC
    </tt>
    的位置：
    <pre>$ scan-build <b>./configure</b></pre>
    <p>
        <tt>
            scan-build
        </tt>
        有特别的关于
        <tt>
            configure
        </tt>
        的“知识”，因此在大多数情况下，都不会实际地分析通过
        <tt>
            configure
        </tt>
        执行的配置测试。
    </p>
    <p>
    	在这个hood下，
        <tt>
            ccc-analyzer
        </tt>
        直接调用
        <tt>
            gcc
        </tt>
        实际的代码，除了执行分析器之外（这是由它调用
        <tt>
            clang
        </tt>
        造成的）。
        <tt>
            ccc-analyzer
        </tt>
        尝试转发全部的参数到
        <tt>
            gcc
        </tt>
        ，但这是有可能无法完美地工作的（对于这种情况请报告bug）。
    <h2 id="iphone">
        分析iPhone项目
    </h2>
    <p>
    	概念上iPhone，应用和它的堂兄桌面应用几乎是一样的。
        <b>
            scan-build
        </b>
        也可以分析这些项目，但用户在命令行中build它们的iPhone项目时，经常会遇到问题，因为这一有一些预备的步骤必须要做（例如设置代码签名）。
    </p>
    <h3>
        Recommendation: use "Build and Analyze"
    </h3>
    <p>
    	分析iPhone项目绝对最容易的办法是使用Xcode的
        <a href="https://developer.apple.com/library/ios/recipes/xcode_help-source_editor/chapters/Analyze.html#//apple_ref/doc/uid/TP40009975-CH4-SW1">
            <i>
                Analyze
            </i>
            特性
        </a>
        （它基于Clang的静态分析）。在这里用户可以在无需大多数以下描述的情况下，直接从菜单分析它们的项目。
    </p>
    <p>
    	关于怎么使用开源的分析器的build来替换被打包在Xcode中的那个，指导在
        <a href="http://clang-analyzer.llvm.org/xcode.html">
            这个网址
        </a>
        上。
    </p>
    <h3>
        Using scan-build directly
    </h3>
    <p>
    	如果你想要在你的iPhone项目中使用
        <b>
            scan-build
        </b>
        记住下列事项：
    </p>
    <ul>
        <li>
        	在
            <tt>
                Debug
            </tt>
            配置下分析项目。既可以在Xcode中设置来作为你的配置，也可以传递参数
            <tt>
                -configuration Debug
            </tt>
            给
            <tt>
                xcodebuild
            </tt>
            。
        </li>
        <li>
        	使用
            <tt>
                Simulator
            </tt>
            作为你的base SDK来分析项目。这样分析你的代码可能需要定位设备，但它会比使用Xcode的
            <i>
                Build and Analyze
            </i>
            特性更容易。
        </li>
        <li>
        	还需要检查的你的代码签名SDK被设置为了模拟器的SDK，并确保这个选项被设置为
            <tt>
                Don't Code Sign
            </tt>
            。
        </li>
    </ul>
    <p>
    	注意大部分情况下，你都不需要实际地修改你的项目。
    	例如，如果你的应用targets了iPhoneOS 2.2，你可以在命令行中以下列形式执行
        <b>
            scan-build
        </b>
        ：
    </p>
    <pre class="code_example">$ scan-build xcodebuild -configuration Debug -sdk iphonesimulator2.2</pre>
    相应地，如果你的应用targets了iPhoneOS 3.0：
    <pre class="code_example">$ scan-build xcodebuild -configuration Debug -sdk iphonesimulator3.0</pre>
    <h3>
        Gotcha: using the right compiler
    </h3>
    <p>
    	回想一下，
        <b>
            scan-build
        </b>
        通过使用一个编译器来编译项目，用
        <tt>
            clang
        </tt>
        来分析项目，实现分析项目的效果。这个脚本使用简单的试探法（heuristics）来确定该使用哪个编译器（默认在Darwin上是
        <tt>
            clang
        </tt>
        在其它平台上则是
        <tt>
            gcc
        </tt>
        ）。当分析iPhone项目的时候，
        <b>
            scan-build
        </b>
        可能会选取错误的编译器，没有选择Xcode用来build你的项目的那个。例如，可能在你的系统上装有多个版本的编译器，尤其在你要开发iPhone的时候。
    </p>
    <p>
    	当编译你的应用去运行在模拟器上的时候，让
        <b>
            scan-build
        </b>
        找到正确版本的
        <tt>
            gcc/clang
        </tt>
        是非常重要的。否则，你就可能会看到奇怪的build错误当且仅当你执行
        <tt>
            scan-build
        </tt>
        的时候。
    </p>
    <p>
        <b>
            scan-build
        </b>
        提供了
        provides the
        <tt>
            --use-cc
        </tt>
        and
        和
        <tt>
            --use-c++
        </tt>
        选项来强制选择（hardwire）scan-build用来build你代码的编译器。注意，尽管你的兴趣主要在分析你的项目上，记住运行分析器是和build密切相关的，如果不能编译你的代码，也就意味着无法得到完整的分析。
    </p>
    <p>
    	如果你不能确定Xcod是用哪个编译器来build你的项目，尝试运行
        <tt>
            xcodebuild
        </tt>
        （不要
        <b>
            scan-build
        </b>
        ）。你应该就看到Xcode正在用的那个编译器的全路径了，使用它来作为
        <tt>
            --use-cc
        </tt>
        的参数。
    </p>
</div>
